// Generated by CoffeeScript 1.7.1
(function() {
  var TokenType, Tokenizer, isAlphanumeric, isBracket, isCurlyBrace, isKeyword, isLetter, isLowercaseLetter, isNewline, isNumber, isOperator, isSquareBracket, isUnderscore, isUppercaseLetter, isWhitespace;

  isNumber = function(char) {
    return char === "0" || char === "1" || char === "2" || char === "3" || char === "4" || char === "5" || char === "6" || char === "7" || char === "8" || char === "9";
  };

  isLowercaseLetter = function(char) {
    return char === "a" || char === "b" || char === "c" || char === "d" || char === "e" || char === "f" || char === "g" || char === "h" || char === "i" || char === "j" || char === "k" || char === "l" || char === "m" || char === "n" || char === "o" || char === "p" || char === "q" || char === "r" || char === "s" || char === "t" || char === "u" || char === "v" || char === "w" || char === "x" || char === "y" || char === "z";
  };

  isUppercaseLetter = function(char) {
    return char === "A" || char === "B" || char === "C" || char === "D" || char === "E" || char === "F" || char === "G" || char === "H" || char === "I" || char === "J" || char === "K" || char === "L" || char === "M" || char === "N" || char === "O" || char === "P" || char === "Q" || char === "R" || char === "S" || char === "T" || char === "U" || char === "V" || char === "W" || char === "X" || char === "Y" || char === "Z";
  };

  isLetter = function(char) {
    return isLowercaseLetter(char) || isUppercaseLetter(char);
  };

  isUnderscore = function(char) {
    return char === "_";
  };

  isAlphanumeric = function(char) {
    return isNumber(char) || isLetter(char) || isUnderscore(char);
  };

  isNewline = function(char) {
    return char === "\n" || char === "\r" || char === "\n\r" || char === "\r\n";
  };

  isKeyword = function(identifier) {
    return identifier === "if" || identifier === "function" || identifier === "and" || identifier === "then" || identifier === "do" || identifier === "for" || identifier === "while" || identifier === "end" || identifier === "repeat" || identifier === "until" || identifier === "local" || identifier === "goto" || identifier === "or" || identifier === "not" || identifier === "true" || identifier === "false" || identifier === "return" || identifier === "else" || identifier === "elseif" || identifier === "nil" || identifier === "in" || identifier === "switch" || identifier === "when" || identifier === "case" || identifier === "is" || identifier === "isnt" || identifier === "unless" || identifier === "elif" || identifier === "def" || identifier === "new" || identifier === "class";
  };

  isOperator = function(identifier) {
    return identifier === "=" || identifier === "+" || identifier === "-" || identifier === ":" || identifier === ";" || identifier === "," || identifier === "*" || identifier === "/" || identifier === ">" || identifier === "<" || identifier === "<=" || identifier === ">=" || identifier === "~=" || identifier === "~" || identifier === "^" || identifier === ".." || identifier === "==" || identifier === "%" || identifier === "#" || identifier === "?" || identifier === ".." || identifier === "..." || identifier === ".";
  };

  isWhitespace = function(char) {
    return char === " " || char === "\t";
  };

  isBracket = function(char) {
    return char === "(" || char === ")";
  };

  isSquareBracket = function(char) {
    return char === "[" || char === "]";
  };

  isCurlyBrace = function(char) {
    return char === "{" || char === "}";
  };

  TokenType = {
    NUMBER: "NUMBER",
    IDENTIFIER: "IDENTIFIER",
    COMMENT: "COMMENT",
    MULTILINE_COMMENT: "MULTILINE_COMMENT",
    STRING: "STRING",
    KEYWORD: "KEYWORD",
    OPERATOR: "OPERATOR",
    OTHER: "OTHER",
    WHITESPACE: "WHITESPACE",
    BRACKET: "BRACKET",
    SQUARE_BRACKET: "SQUARE_BRACKET",
    CURLY_BRACE: "CURLY_BRACE",
    NEWLINE: "NEWLINE",
    EOF: "EOF"
  };

  Tokenizer = (function() {
    function Tokenizer(source) {
      this.source = source;
      this.length = this.source.length;
      this.characterIndex = -1;
      this.lineNumber = 1;
      this.currentToken = "";
      this.currentCharacter = "";
      this.parseMultiline = null;
      this.next = "";
    }

    Tokenizer.prototype.nextChar = function() {
      var character;
      this.characterIndex += 1;
      if (this.characterIndex >= this.length) {
        return null;
      }
      character = this.source.charAt(this.characterIndex);
      if (isNewline(character)) {
        this.lineNumber += 1;
      }
      return character;
    };

    Tokenizer.prototype.peek = function(amount) {
      if (amount == null) {
        amount = 1;
      }
      if (this.characterIndex + amount >= this.length) {
        return null;
      } else {
        return this.source.charAt(this.characterIndex + amount);
      }
    };

    Tokenizer.prototype.parseNumber = function() {
      this.currentToken = this.currentCharacter;
      while ((this.next != null) && (isNumber(this.next) || this.next === ".")) {
        this.currentToken += this.nextChar();
        this.next = this.peek();
      }
      return [this.currentToken, TokenType.NUMBER];
    };

    Tokenizer.prototype.parseIdentifier = function() {
      this.currentToken = this.currentCharacter;
      while ((this.next != null) && isAlphanumeric(this.next)) {
        this.currentToken += this.nextChar();
        this.next = this.peek();
      }
      if (isKeyword(this.currentToken)) {
        return [this.currentToken, TokenType.KEYWORD];
      } else {
        return [this.currentToken, TokenType.IDENTIFIER];
      }
    };

    Tokenizer.prototype.parseMultilineComment = function() {
      var char;
      this.parseMultiline = this.parseMultilineComment;
      if (isNewline(this.currentCharacter)) {
        char = this.currentCharacter;
        this.currentCharacter = "";
        return [char, TokenType.MULTILINE_COMMENT];
      }
      while (true) {
        this.currentCharacter = this.nextChar();
        if (this.currentCharacter == null) {
          break;
        }
        if (isNewline(this.currentCharacter)) {
          break;
        }
        this.currentToken += this.currentCharacter;
        if (this.currentCharacter === "]" && this.peek() === "]") {
          this.currentToken += this.nextChar();
          this.parseMultiline = null;
          break;
        }
      }
      return [this.currentToken, TokenType.MULTILINE_COMMENT];
    };

    Tokenizer.prototype.parseComment = function() {
      this.currentToken = this.currentCharacter;
      this.currentToken += this.nextChar();
      this.next = this.peek();
      if (this.next === "[" && this.peek(2) === "[") {
        return this.parseMultilineComment();
      } else {
        while ((this.next != null) && !isNewline(this.next)) {
          this.currentToken += this.nextChar();
          this.next = this.peek();
        }
        return [this.currentToken, TokenType.COMMENT];
      }
    };

    Tokenizer.prototype.parseString = function() {
      var readEscapeCharacter, stringOpener;
      this.currentToken = this.currentCharacter;
      stringOpener = this.currentCharacter;
      readEscapeCharacter = false;
      while (this.next != null) {
        this.next = this.peek();
        if (this.next === stringOpener && !readEscapeCharacter) {
          break;
        }
        if (!readEscapeCharacter && this.next === "\\") {
          readEscapeCharacter = true;
        } else {
          readEscapeCharacter = false;
        }
        this.currentToken += this.nextChar();
      }
      this.currentToken += this.nextChar();
      return [this.currentToken, TokenType.STRING];
    };

    Tokenizer.prototype.parseOther = function() {
      this.currentToken = this.currentCharacter;
      if (isWhitespace(this.currentCharacter)) {
        this.next = this.peek();
        while ((this.next != null) && isWhitespace(this.next)) {
          this.currentToken += this.nextChar();
          this.next = this.peek();
        }
        return [this.currentToken, TokenType.WHITESPACE];
      } else {
        if (isBracket(this.currentToken)) {
          return [this.currentToken, TokenType.BRACKET];
        } else if (isSquareBracket(this.currentToken)) {
          return [this.currentToken, TokenType.SQUARE_BRACKET];
        } else if (isCurlyBrace(this.currentToken)) {
          return [this.currentToken, TokenType.CURLY_BRACE];
        } else {
          return [this.currentToken, TokenType.OTHER];
        }
      }
    };

    Tokenizer.prototype.parseOperator = function() {
      this.currentToken = this.currentCharacter;
      while ((this.next != null) && isOperator(this.next)) {
        this.currentToken += this.nextChar();
        this.next = this.peek();
      }
      return [this.currentToken, TokenType.OPERATOR];
    };

    Tokenizer.prototype.nextToken = function() {
      this.currentToken = "";
      if (this.parseMultiline != null) {
        return this.parseMultiline();
      }
      this.currentCharacter = this.nextChar();
      this.next = this.peek();
      switch (false) {
        case !(isNumber(this.currentCharacter) || (this.currentCharacter === "." && isNumber(this.next)) || (this.currentCharacter === "-" && (this.next === "." || isNumber(this.next)))):
          return this.parseNumber();
        case !(isLetter(this.currentCharacter) || isUnderscore(this.currentCharacter)):
          return this.parseIdentifier();
        case !(this.currentCharacter === "-" && this.next === "-"):
          return this.parseComment();
        case !(this.currentCharacter === "\"" || this.currentCharacter === "'"):
          return this.parseString();
        case !isOperator(this.currentCharacter):
          return this.parseOperator();
        case this.currentCharacter == null:
          return this.parseOther();
        default:
          return ["", TokenType.EOF];
      }
    };

    return Tokenizer;

  })();

  $(document).ready(function() {
    return $("code").each(function() {
      var $code, $highlightedCode, $lineNumbers, $parent, $span, currentLine, indentChangeThisLine, indentChangedThisLine, indentation, isFirstLine, language, lastTokenType, lineCount, newLineAfterBracket, previousToken, shouldHaveNewLine, shouldHighlight, source, text, token, tokenizer, tokens, totalLineCount, totalLineCountLength, type, _i, _len;
      $code = $(this);
      shouldHighlight = $code.data("should-highlight");
      source = $code.text();
      language = $code.data("language") || "plain";
      tokenizer = new Tokenizer(source);
      tokens = (function() {
        var _results;
        _results = [];
        while ((token = tokenizer.nextToken())[1] !== TokenType.EOF) {
          _results.push(token);
        }
        return _results;
      })();
      totalLineCount = tokenizer.lineNumber;
      totalLineCountLength = totalLineCount.toString().length;
      $parent = $code.parent();
      $parent.addClass("highlighted-code");
      $lineNumbers = $("<code>");
      $lineNumbers.addClass("line-numbers");
      $highlightedCode = $("<code>");
      $highlightedCode.addClass("code");
      currentLine = 1;
      lineCount = 0;
      indentation = 0;
      tokens.push(["", TokenType.WHITESPACE]);
      lastTokenType = null;
      newLineAfterBracket = 1;
      shouldHaveNewLine = false;
      indentChangeThisLine = 0;
      indentChangedThisLine = false;
      isFirstLine = true;
      previousToken = ["\n", TokenType.OTHER];
      for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        if (isNewline(previousToken[0])) {
          lineCount += 1;
          if (!isFirstLine) {
            $lineNumbers.append("\n");
          }
          isFirstLine = false;
          $lineNumbers.append(lineCount);
        }
        text = token[0];
        type = token[1];
        $span = $("<span>");
        $span.text(text);
        if (shouldHighlight) {
          $span.addClass(type.toLowerCase().replace("_", "-"));
        }
        $highlightedCode.append($span);
        previousToken = token;
      }
      $code.after($lineNumbers);
      $lineNumbers.after($highlightedCode);
      return $code.remove();
    });
  });

}).call(this);
